#!/usr/bin/perl
#Sumbit job for execution
package oarsub;
require Exporter;

use strict;

#use warnings;
use POSIX qw(strftime);
use Fcntl;
use Data::Dumper;
use Sys::Hostname;
use Getopt::Long;
use File::Basename;
use File::Temp qw/ tempfile /;
use Cwd;
use OAR::Conf qw(init_conf dump_conf get_conf is_conf);
use OAR::Sub;

my $Old_umask = sprintf("%lo", umask());
umask(oct("022"));

select(STDOUT);
$| = 1;

#Try to load XML module
my $XML_enabled = 1;
unless (eval "use XML::Dumper qw(pl2xml);1") {
    $XML_enabled = 0;
}

#Try to load YAML module
my $YAML_enabled = 1;
unless (eval "use YAML;1") {
    $YAML_enabled = 0;
}

#Try to load JSON module
my $JSON_enabled = 1;
unless (eval "use JSON;1") {
    $JSON_enabled = 0;
}

# suitable Data::Dumper configuration for serialization
$Data::Dumper::Purity   = 1;
$Data::Dumper::Terse    = 1;
$Data::Dumper::Indent   = 0;
$Data::Dumper::Deepcopy = 1;

#For interactive
my $remote_host;
my $remote_port;
my $Deploy_hostname;
my $Cosystem_hostname;
my $Deploy_cosystem_job_exec_system;
my $Cpuset_field;
my $Cpuset_path;
my $Host = hostname;

my $Server;
my $Job_id;
my $Job_id_list_ref;
my $Interactive = 0;
my $Reservation = "0";
my $Reservation_start;
my $Reservation_end;
my $Default_resources;
my $Nodes_resources;
my $connect_job;
my $Scan_script;
my @resource;
my $Queue_name;
my $Job_sql_properties = "";
my $Cmd_executor;
my $idFile = undef;
my $sos;
my $Checkpoint = 0;
my $notify;
my $job_name;
my $job_env;
my $job_hold;
my $Directory;
my $Directory_default = getcwd();
my @Type;
my @Anterior_job;
my $Checkpoint_signal;
my $Checkpoint_signal_default = 12;    # SIGUSR2
my $Stdout_file;
my $Stderr_file;
my $Resubmit;
my $Project;
my $Project_default = "default";
my $XML_mode;
my $YAML_mode;
my $JSON_mode;
my $DUMPER_mode;
my $use_job_key;
my $job_key_priv           = "";
my $job_key_pub            = "";
my $import_job_key_file    = "";
my $import_job_key_inline  = "";
my $export_job_key_file    = "";
my $Initial_request_string = "oarsub @ARGV";
my $Verbose_level;
my $lusr = $ENV{OARDO_USER};

# a non array-job is an array-job with 1 subjob
my $array_job_nb;
my $array_param_file;
my $array_params_ref;

#to catch ^C signal
$SIG{INT}  = \&signal_handler;
$SIG{HUP}  = \&signal_handler;
$SIG{PIPE} = \&signal_handler;

# to address ^C in interactive submission
sub signal_handler($) {
    my $signal = shift;
    if (defined($Job_id_list_ref)) {
        if ($signal eq "INT") {
            print(STDERR "\n\n# Caught Interrupt (^C), ");
        }
        OAR::Sub::delete_jobs($Job_id_list_ref, $remote_host, $remote_port);
        OAR::Sub::close_db_connection();
        exit(1);
    }
}

# Connect to a job and give the shell of the user on the remote host
sub connect_job($$$) {
    my $job_id       = shift;
    my $stop_oarexec = shift;
    my $openssh_cmd  = shift;

    my $xauth_path = $ENV{OARXAUTHLOCATION};
    OAR::Sub::open_ro_db_connection();
    my $job = OAR::Sub::get_job($job_id);

    if ((($lusr eq $job->{job_user}) or ($lusr eq "oar")) && ($job->{state} eq "Running")) {
        my $types = OAR::Sub::get_current_job_types($job_id);

        #noop
        if (defined($types->{noop})) {
            warn("# Error: it is not possible to connect to a NOOP job.\n");
            OAR::Sub::close_db_connection();
            exit(17);
        }
        my $hosts_tmp               = OAR::Sub::get_job_current_hostnames($job_id);
        my @hosts                   = @$hosts_tmp;
        my $host_to_connect_via_ssh = $hosts[0];

        #deploy, cosystem and no host part
        if ((defined($types->{cosystem})) or ($#hosts < 0)) {
            $host_to_connect_via_ssh = $Cosystem_hostname;
        } elsif (defined($types->{deploy})) {
            $host_to_connect_via_ssh = $Deploy_hostname;
        }

        #cpuset part
        if (
            (   defined($Cpuset_field)         and
                defined($Cpuset_path)          and
                (!defined($types->{cosystem})) and
                (!defined($types->{deploy}))   and
                ($#hosts >= 0))
        ) {
            $ENV{OAR_CPUSET} = $Cpuset_path . '/' . OAR::Sub::get_job_cpuset_name($job_id);
        } else {
            $ENV{OAR_CPUSET} = "";
        }
        my $moldable = OAR::Sub::get_current_moldable_job($job->{assigned_moldable_job});
        my $job_user = $job->{job_user};
        OAR::Sub::close_db_connection();
        my @passinfo = getpwnam($lusr) or
          die("Cannot retreive system information for user $lusr\n");
        my $shell = $passinfo[8];
        my $uid   = $passinfo[2];
        unless ((defined($xauth_path)) and
            (-x $xauth_path) and
            ($ENV{DISPLAY} =~ /^[\w.-]*:\d+(?:\.\d+)?$/)) {
            $ENV{DISPLAY} = "";
        }
        if ($ENV{DISPLAY} ne "") {
            if ($Verbose_level >= 1) {
                print("# Initialize X11 forwarding...\n");
            }

            # first, get rid of remaining unused .Xautority.{pid} files...
            system(
                {"bash"} "bash",
                "-c",
                'for f in $HOME/.Xauthority.*; do [ -e "/proc/${f#$HOME/.Xauthority.}" ] || rm -f $f; done'
            );
            my $new_xauthority = $ENV{HOME} . "/.Xauthority.$$";
            system(
                {"bash"} "bash",
                "-c",
                '[ -x "' . $xauth_path .
                  '" ] && OARDO_BECOME_USER=' . $lusr . ' oardodo bash --noprofile --norc -c "' .
                  $xauth_path . ' extract - ${DISPLAY/#localhost:/:}" | XAUTHORITY=' .
                  $new_xauthority . ' ' . $xauth_path . ' -q merge - 2>/dev/null');
            $ENV{XAUTHORITY} = $new_xauthority;
        }
        my $node_file   = OAR::Sub::get_default_oarexec_directory() . "/$job_id";
        my $res_file    = OAR::Sub::get_default_oarexec_directory() . "/$job_id" . "_resources";
        my $oarsub_pids = OAR::Sub::get_oarsub_connections_file_name($job_id);
        my %params      = (
            "node_file"           => $node_file,
            "job_id"              => $job_id,
            "array_id"            => $job->{array_id},
            "array_index"         => $job->{array_index},
            "user"                => $lusr,
            "shell"               => $shell,
            "launching_directory" => $job->{launching_directory},
            "resource_file"       => $res_file,
            "job_name"            => $job->{job_name},
            "job_project"         => $job->{project},
            "job_walltime"        => OAR::Sub::duration_to_sql($moldable->{moldable_walltime}),
            "job_walltime_sec"    => $moldable->{moldable_walltime},
            "job_env"             => $job->{job_env});
        my $str = OAR::Sub::get_oarexecuser_script_for_oarsub(\%params);
        my ($cmd_name, @cmd_opts) = split(" ", $openssh_cmd);
        my @cmd;
        my $i = 0;
        $cmd[$i] = $cmd_name;
        $i++;

        foreach my $p (@cmd_opts) {
            $cmd[$i] = $p;
            $i++;
        }
        if ($ENV{OAR_CPUSET} ne "") {
            $cmd[$i] = "-oSendEnv=OAR_CPUSET";
            $i++;
        }
        if ($ENV{DISPLAY} ne "") {
            $cmd[$i] = "-X";
        } else {
            $cmd[$i] = "-x";
        }
        $i++;
        $cmd[$i] = "-t";
        $i++;
        $cmd[$i] = $host_to_connect_via_ssh;
        $i++;
        $str =~ s/\n//g;
        my $interactive_job_hook_file = get_conf("INTERACTIVE_JOB_HOOK_EXEC_FILE");
        my $interactive_job_hook_cmd;

        if (defined($interactive_job_hook_file)) {
            $interactive_job_hook_cmd =
              "if test -x $interactive_job_hook_file; then oardodo $interactive_job_hook_file \$\$,\$PPID:$lusr:$job_id:$job->{name}:$job->{project}:$moldable->{moldable_walltime}; else true; fi && ";
        }

        my $oardodo_cmd = "OARDO_BECOME_USER=$job_user oardodo bash --noprofile --norc -c '$str'";
        if (defined($types->{cosystem}) or defined($types->{deploy}) or ($#hosts < 0)) {
            if ($Deploy_cosystem_job_exec_system eq "systemd-run") {
                $oardodo_cmd =
                  "oardodo systemd-run -q --uid=$uid --pty --wait --collect --service-type=exec --slice=user-$uid.slice /bin/bash --noprofile --norc -c '$str'";
            } elsif ($Deploy_cosystem_job_exec_system eq "none") {

                # Use regular command by default
            }
        }

        if ($ENV{DISPLAY} ne "") {
            $cmd[$i] =
              "bash -c '${interactive_job_hook_cmd}echo \$PPID >> $oarsub_pids && ($xauth_path -q extract - \${DISPLAY/#localhost:/:} | OARDO_BECOME_USER=$lusr oardodo $xauth_path merge -) && [ \"$lusr\" != \"$job_user\" ] && OARDO_BECOME_USER=$lusr oardodo bash --noprofile --norc -c \"chmod 660 \\\$HOME/.Xauthority\" ;TTY=\$(tty) && test -e \$TTY && oardodo chown $job_user:oar \$TTY && oardodo chmod 660 \$TTY' && $oardodo_cmd";
            $i++;
        } else {
            $cmd[$i] =
              "bash -c '${interactive_job_hook_cmd}echo \$PPID >> $oarsub_pids && TTY=\$(tty) && test -e \$TTY && oardodo chown $job_user:oar \$TTY && oardodo chmod 660 \$TTY' && $oardodo_cmd";
            $i++;
        }

        #essential: you become oar instead of the user
        #UID=EUID
        $< = $>;
        if ($Verbose_level >= 1) {
            print("# Connect to OAR job $job_id via node $host_to_connect_via_ssh\n");
        }
        system({ $cmd[0] } @cmd);
        my $exit_value = $? >> 8;
        if ($exit_value == 2) {
            warn("# Error: cannot go into working directory: $job->{launching_directory}.\n");
        } elsif ($exit_value == 255) {
            warn("# Error: job was terminated.\n");
        } elsif ($exit_value != 0) {
            warn("# Error: an unknown error occured ($?).\n");
        }
        if ($stop_oarexec > 0) {
            my %params = (
                "host"         => $host_to_connect_via_ssh,
                "job_id"       => $job_id,
                "signal"       => "USR1",
                "time_to_wait" => 0,
                "ssh_cmd"      => $openssh_cmd);
            OAR::Sub::signal_oarexec(\%params);
        }
        print("Disconnected from OAR job $job_id.\n");
    } else {
        if ($job->{state} ne "Running") {
            warn("# Error: job $job_id is not running. Its current state is $job->{state}.\n");
        }
        if (($lusr ne $job->{job_user}) and ($lusr ne "oar")) {
            warn(
                "# Error: you are not the right user for job $job_id. This job is owned by $job->{job_user}.\n"
            );
        }
        OAR::Sub::close_db_connection();
        return (20);
    }
    return (0);
}

#Print help message
sub usage() {
    print <<EOS;
Usage: $0 [options] [-I|-C [<job id>]|-r <start date>[, <end date>]|<script>]
Submit a job the OAR batch scheduler
Options are:
 -I, --interactive             Request an interactive job.
 -C, --connect[=<job id>]      Connect to a running job. Job id may be omitted
                               if only one job is running.
 -l, --resource=<description>[,<walltime>]
                               Set the description of the requested resources
                               for the job and a walltime which specifies an
                               estimation of the maximum duration of the job
                               (the job process can terminate earlier).
                               Ex: host=4/cpu=1,walltime=2:00:00
                               Option can be used several times, to define a
                               moldable job: a job accepting different
                               combination of resource definitions.
     --array <number>          Specify an array job with 'number' subjobs
     --array-param-file <file> Specify an array job on which each subjob will
                               receive one line of the file as parameter.
 -S, --scanscript              Request oarsub to scan the script file given as
                               the job command, for extra options to apply to
                               the job (lines starting with #OAR).
 -q, --queue=<queue>           Set the queue to submit the job to.
 -p, --property="<SQL WHERE CLAUSE>"
                               Add constraints to the wanted resource for the
                               job, using the resources properties.
                               Constraints use the SQL WHERE CLAUSE syntax.
 -r, --reservation="<start date|now>[, <end date>]"
                               Request that the job starts (and optionally
                               ends) at a specified time. Using this option,
                               the job is called an advance reservation.
                               Start and end dates use the YYYY-MM-DD hh:mm:ss
                               format. If YYYY-MM-DD is omitted, it defaults to
                               the current day. In hh:mm:ss, ss and mm can be
                               omitted. Quotes are only required when spaces
                               are present. When an end date is provided the
                               job walltime is inferred, unless provided in the
                               -l resources request which prevails. The special
                               keyword now can be used as the start date to
                               request an advance reservation job that starts
                               just now.
     --checkpoint=<delay>      Enable the checkpointing for the job. A signal
                               is sent DELAY seconds before the walltime on
                               the first processus of the job.
     --signal=<#sig>           Specify the signal to use when checkpointing
                               Use signal numbers, default is 12 (SIGUSR2).
 -t, --type=<type>             Specify a specific type (deploy, besteffort,
                               cosystem, checkpoint, timesharing). Option can
                               be specified several times.
 -d, --directory=<dir>         Specify the directory where to launch the
                               command (default is current directory).
     --project=<txt>           Specify a name of a project the job belongs to.
 -n, --name=<txt>              Specify an arbitrary name for the job.
 -a, --anterior=<job id>       Anterior job that must be terminated to start
                               this new one.
     --notify=<txt>            Specify a notification method
                               (mail or command to execute). Ex:
                                   --notify "mail:name\@domain.com"
                                   --notify "exec:/path/to/script args"
     --resubmit=<job id>       Resubmit the given job as a new one.
 -k, --use-job-key             Activate the job-key mechanism.
 -i, --import-job-key-from-file=<file>
                               Import the job-key to use from a files instead
                               of generating a new one.
     --import-job-key-inline=<txt>
                               Import the job-key to use inline instead of
                               generating a new one.
 -e  --export-job-key-to-file=<file>
                               Export the job key to a file. Warning: the
                               file will be overwritten if it already exists.
                               (the %jobid% pattern is automatically replaced)
 -O  --stdout=<file>           Specify the file that will store the standart
                               output stream of the job.
                               (the %jobid% pattern is automatically replaced)
 -E  --stderr=<file>           Specify the file that will store the standart
                               error stream of the job.
                               (the %jobid% pattern is automatically replaced)
     --hold                    Set the job state into Hold instead of Waiting,
                               so that it is not scheduled (you must run
                               "oarresume" to turn it into the Waiting state).
 -D, --dumper                  Print result in DUMPER format.
 -X, --xml                     Print result in XML format.
 -Y, --yaml                    Print result in YAML format.
 -J, --json                    Print result in JSON format.
 -h, --help                    Print this help message.
 -V, --version                 Print OAR version number.
 -v,                           Verbose mode, oarsub and admissions rules (if
                               compatible) will print more information on
                               terminal. Multiple -v can be used to increase
                               the level of verbosity (max: 2).
EOS
}

# Parse -l options and return an array of hashtables with resources for a moldable job
sub parse_resource_descriptions($) {
    my $resource_ref = shift;

    my @resource = @{$resource_ref};
    if ($#resource < 0) {
        push(@resource, $Default_resources);
    }

    #print "--@resource--\n";

    my @result;
    foreach my $r (@resource) {
        my @resource_groups;
        my $end_loop = 0;
        while ($end_loop == 0) {
            my $initial_resource = $r;
            my %tmp_result;
            if ($r =~ /^\s*(\++|\,+|\s*)\s*\{(.+?)}(.*)$/) {

                # $1 = property string
                $tmp_result{property} = $2;
                $r = $3;
            }

            my $resources_to_parse;
            if (($r =~ /^\s*(\++|\,+|\s*)\s*[\/]*([^\,\+]+)\s*(.*)$/) and ($2 !~ /^\s*walltime/)) {
                $resources_to_parse = $2;
                $r                  = $3;
            } else {
                $Default_resources =~ /^\s*[\/]*(.+)$/;

                # Remove first /
                $resources_to_parse = $1;
            }
            my @slash_split = split('\/', $resources_to_parse);
            my @resources_list;
            foreach my $l (@slash_split) {
                if ($l =~ /^\s*(\w+)\s*=\s*(\d+)\s*$/) {
                    my $tmp = $1;
                    $tmp = $Nodes_resources if ($tmp eq "nodes");
                    push(@resources_list, { resource => $tmp, value => $2 });
                } elsif ($l =~ /^\s*(\w+)\s*=\s*ALL\s*$/) {
                    my $tmp = $1;
                    $tmp = $Nodes_resources if ($tmp eq "nodes");
                    push(@resources_list, { resource => $tmp, value => -1 });
                } elsif ($l =~ /^\s*(\w+)\s*=\s*BESTHALF\s*$/) {
                    my $tmp = $1;
                    $tmp = $Nodes_resources if ($tmp eq "nodes");
                    push(@resources_list, { resource => $tmp, value => -3 });
                } elsif ($l =~ /^\s*(\w+)\s*=\s*BEST\s*$/) {
                    my $tmp = $1;
                    $tmp = $Nodes_resources if ($tmp eq "nodes");
                    push(@resources_list, { resource => $tmp, value => -2 });
                } else {
                    die("# Error: cannot recognize the resource description: $l\n");
                }
            }
            $tmp_result{resources} = \@resources_list;

            if ($r =~ /^[\s\,]*walltime\s*=\s*([\d|:]+)\s*$/) {

                #walltime part
                my ($w_h, $w_mn, $w_sec) = split(':', $1);
                if (defined($w_h)) {
                    if (not defined($w_mn)) {
                        $resource_groups[1] = "$w_h:00:00";
                    } elsif (not defined($w_sec)) {
                        $resource_groups[1] = "$w_h:$w_mn:00";
                    } else {
                        $resource_groups[1] = "$w_h:$w_mn:$w_sec";
                    }
                    $resource_groups[1] = OAR::Sub::sql_to_duration("$resource_groups[1]");
                } else {
                    die("# Error: cannot recognize walltime resource value\n");
                }
                $r = $2;
            }
            if ($r eq $initial_resource) {
                die("# Error: cannot recognize -- $r -- resource\n");
            }
            push(@{ $resource_groups[0] }, \%tmp_result);

            if ($r =~ /^\s*$/) {
                $end_loop = 1;
            }
        }
        push(@result, \@resource_groups);
    }

    return (@result);
}

sub parse_reservation($$) {
    my $interactive   = shift;
    my $resource_list = shift;
    my $server_port;
    my $time_format = "(0?[0-9]|1[0-9]|2[0-3])(?::(0?[0-9]|[1-5][0-9])(?::(0?[0-9]|[1-5][0-9]))?)?";
    my $time_format_regex = qr/^\s*$time_format\s*$/;
    my $date_format_regex =
      qr/^\s*(\d{4}\-(?:0?[0-9]|1[0-2])\-(?:0?[1-9]|[1-2][0-9]|3[0-1]))\s+$time_format\s*$/;

    if ($Reservation ne "0") {

        #Split the Reservation into the start and end time, then test if the syntax is right
        ($Reservation_start, $Reservation_end) = split(/\s*,\s*/, $Reservation);
        chomp($Reservation_start);
        if ($Reservation_start =~ m/$date_format_regex/m) {
            $Reservation_start = OAR::Sub::sql_to_local("$1 $2 $3 $4");
        } elsif ($Reservation_start =~ m/$time_format_regex/m) {
            my ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = localtime(time);
            my $res_str = OAR::Sub::ymdhms_to_sql($year, $mon, $mday, $1, $2, $3);
            $Reservation_start = OAR::Sub::sql_to_local("$res_str");
        } elsif ($Reservation_start eq "now") {
            my ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = localtime(time);
            my $now_str = OAR::Sub::ymdhms_to_sql($year, $mon, $mday, $hour, $min, $sec);
            $Reservation_start = OAR::Sub::sql_to_local("$now_str");
        } else {
            warn(
                "# Error: syntax error in <start date> for the -r or --reservation option. It takes a date as argument with the format: \"YYYY-MM-DD hh:mm:ss\".\n"
            );
            OAR::Sub::close_db_connection;
            exit(7);
        }

        if ($interactive eq 0) {
            ($Server, $server_port) = OAR::Sub::init_tcp_server();
        }
    }

    if ($Reservation_end ne undef) {

        #Test if this job has a reservation end and the syntax is right
        if ($Reservation_end =~ m/$date_format_regex/m) {
            $Reservation_end = OAR::Sub::sql_to_local("$1 $2 $3 $4");
        } elsif ($Reservation_end =~ m/$time_format_regex/m) {
            my ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = localtime(time);
            my $res_str = OAR::Sub::ymdhms_to_sql($year, $mon, $mday, $1, $2, $3);
            $Reservation_end = OAR::Sub::sql_to_local("$res_str");
        } else {
            warn(
                "# Error: syntax error in <end date> for the -r or --reservation option. It takes a date as argument with the format: \"YYYY-MM-DD hh:mm:ss\".\n"
            );
            OAR::Sub::close_db_connection();
            exit(7);
        }

        my $reservation_walltime = $Reservation_end - $Reservation_start;

        foreach my $list (@{$resource_list}) {
            if ($list->[1] eq undef) {
                $list->[1] = $reservation_walltime;
            }
        }
    }

    if ($interactive eq 1) {
        ($Server, $server_port) = OAR::Sub::init_tcp_server();
    }

    return ($Server, $server_port);
}

sub run_advance_reservation_validation_hook($$) {
    my $hook   = shift;
    my $status = shift;
    my $ret    = system("$hook $Job_id_list_ref->[0] $status");

    if ($ret != 0) {
        warn("# Error: an error occured in the advance reservation validation hook\n");
        exit(1);
    }
}

#
# Main
#

init_conf($ENV{OARCONFFILE});
$remote_host = get_conf("SERVER_HOSTNAME");
$remote_port = get_conf("SERVER_PORT");

$Default_resources = get_conf("OARSUB_DEFAULT_RESOURCES");
if (!defined($Default_resources)) {
    $Default_resources = "/resource_id=1";
}

$Nodes_resources = get_conf("OARSUB_NODES_RESOURCES");
if (!defined($Nodes_resources)) {
    $Nodes_resources = "resource_id";
}

$Deploy_hostname = get_conf("DEPLOY_HOSTNAME");
if (!defined($Deploy_hostname)) {
    $Deploy_hostname = $remote_host;
}

$Cosystem_hostname = get_conf("COSYSTEM_HOSTNAME");
if (!defined($Cosystem_hostname)) {
    $Cosystem_hostname = $remote_host;
}

$Deploy_cosystem_job_exec_system = get_conf("DEPLOY_COSYSTEM_JOB_EXEC_SYSTEM");
if (!defined($Deploy_cosystem_job_exec_system)) {
    $Deploy_cosystem_job_exec_system = "none";
}
if (($Deploy_cosystem_job_exec_system ne "none") and
    ($Deploy_cosystem_job_exec_system ne "systemd-run")) {
    die("[ERROR] Bad configuration for DEPLOY_COSYSTEM_JOB_EXEC_SYSTEM: '$Deploy_cosystem_job_exec_system' is unsupported\n"
    );
}

$Cpuset_field = get_conf("JOB_RESOURCE_MANAGER_PROPERTY_DB_FIELD");
$Cpuset_path  = get_conf("CPUSET_PATH");

if (is_conf("OAR_RUNTIME_DIRECTORY")) {
    OAR::Sub::set_default_oarexec_directory(get_conf("OAR_RUNTIME_DIRECTORY"));
}
my $default_oar_dir = OAR::Sub::get_default_oarexec_directory();
if (!(((-d $default_oar_dir) and (-O $default_oar_dir)) or (mkdir($default_oar_dir)))) {
    die("# Error: cannot create the OAR directory $default_oar_dir or bad permissions.\n");
}

my $binpath;
if (defined($ENV{OARDIR})) {
    $binpath = $ENV{OARDIR} . "/";
} else {
    die("# Error: OARDIR env variable must be defined.\n");
}

my $Openssh_cmd = get_conf("OPENSSH_CMD");
$Openssh_cmd = OAR::Sub::get_default_openssh_cmd() if (!defined($Openssh_cmd));

if (is_conf("OAR_SSH_CONNECTION_TIMEOUT")) {
    OAR::Sub::set_ssh_timeout(get_conf("OAR_SSH_CONNECTION_TIMEOUT"));
}

Getopt::Long::Configure("gnu_getopt");
my $Version;
my @Verbose;

GetOptions(
    "resource|l=s"                 => \@resource,
    "queue|q=s"                    => \$Queue_name,
    "interactive|I"                => \$Interactive,
    "property|p=s"                 => \$Job_sql_properties,
    "reservation|r=s"              => \$Reservation,
    "connect|C:i"                  => \$connect_job,
    "checkpoint=i"                 => \$Checkpoint,
    "help|h"                       => \$sos,
    "notify=s"                     => \$notify,
    "type|t=s"                     => \@Type,
    "directory|d=s"                => \$Directory,
    "name|n=s"                     => \$job_name,
    "project=s"                    => \$Project,
    "hold"                         => \$job_hold,
    "array=i"                      => \$array_job_nb,
    "array-param-file=s"           => \$array_param_file,
    "anterior|a=i"                 => \@Anterior_job,
    "signal=i"                     => \$Checkpoint_signal,
    "stdout|O=s"                   => \$Stdout_file,
    "stderr|E=s"                   => \$Stderr_file,
    "resubmit=i"                   => \$Resubmit,
    "scanscript|S"                 => \$Scan_script,
    "xml|X"                        => \$XML_mode,
    "yaml|Y"                       => \$YAML_mode,
    "json|J"                       => \$JSON_mode,
    "dumper|D"                     => \$DUMPER_mode,
    "use-job-key|k"                => \$use_job_key,
    "import-job-key-inline-priv=s" => \$import_job_key_inline,
    "import-job-key-from-file|i=s" => \$import_job_key_file,
    "export-job-key-to-file|e=s"   => \$export_job_key_file,
    "version|V"                    => \$Version,
    "v"                            => \@Verbose
  ) or
  exit(1);

$Verbose_level = scalar @Verbose;
if ($Verbose_level > 2) {
    $Verbose_level = 2;
}

if (defined($Version)) {
    print("OAR version: " . OAR::Sub::get_oar_version() . "\n");
    exit(0);
}

if (defined($sos)) {
    usage();
    exit(0);
}

# Check the default name of the key if we have to generate it
if (is_conf("OARSUB_FORCE_JOB_KEY")) {
    if (lc(get_conf("OARSUB_FORCE_JOB_KEY")) eq "yes") {
        $use_job_key = 1;
    }
}

# If OAR_JOB_KEY_FILE is set in the shell environment, then imply use_job_key
# because oarsh will use OAR_JOB_KEY_FILE as well and fail if the job is
# setup without a job_key
if (defined($ENV{OAR_JOB_KEY_FILE})) {
    $use_job_key = 1;
}

OAR::Sub::open_db_connection();

if (defined($Resubmit)) {
    if ($Verbose_level >= 1) {
        print("# Resubmitting job $Resubmit...");
    }
    my $err = OAR::Sub::resubmit_job($Resubmit);
    OAR::Sub::close_db_connection();
    if ($err > 0) {
        $Job_id = $err;
        if ($Verbose_level >= 1) {
            print("# DONE\n");
        }
        if ($Job_id > 0 or $Verbose_level >= 1) {
            print("OAR_JOB_ID=$Job_id\n");
        }
        if (defined(OAR::Sub::signal_almighty($remote_host, $remote_port, "Qsub"))) {
            warn(
                "# Error: cannot connect to executor $remote_host:$remote_port. Is OAR started?\n");
            exit(3);
        }
        exit(0);
    } else {
        if ($err == -1) {
            warn("# Error: an interactive job or a reservation cannot be resubmitted.\n");
        } elsif ($err == -2) {
            warn("# Error: the job must be in Error or Terminated state.\n");
        } elsif ($err == -3) {
            warn("# Error: you are not the right user.\n");
        } elsif ($err == -4) {
            warn("# Error: another active job is using the same ssh keys.\n");
        } else {
            warn("# Error: unknown error ($err).\n");
        }
        exit(4);
    }
}

if ((@ARGV != 1) &&
    ($Interactive == 0)    &&
    ($Reservation eq "0")  &&
    !defined($connect_job) &&
    !grep(/^noop(?:=standby)?$/, @Type)) {
    usage();
    OAR::Sub::close_db_connection();
    exit(5);
}

if (($Interactive == 1) and ($Reservation ne "0")) {
    warn("# Error: a reservation cannot be interactive.\n");
    usage();
    OAR::Sub::close_db_connection();
    exit(7);
}

if (($Interactive == 1) and grep(/^noop(?:=standby)?$/, @Type)) {
    warn("# Error: a noop job cannot be interactive.\n");
    OAR::Sub::close_db_connection();
    exit(17);
}

if (defined($notify) && $notify =~ m/^.*exec\s*:.+$/m) {
    my $notify_exec_regexp = '[a-zA-Z0-9_.\/ -]+';
    unless ($notify =~ m/.*exec\s*:($notify_exec_regexp)$/m) {
        warn(
            "# Error: insecure characters found in notification method (the allowed regexp is: $notify_exec_regexp).\n"
        );
        OAR::Sub::close_db_connection();
        exit(16);
    }
}

# Connect to a reservation
if (defined($connect_job)) {
    if ($connect_job eq 0) {
        my @running_jobs = OAR::Sub::get_running_jobs_for_user($lusr);

        if ($#running_jobs < 0) {
            print("No running jobs\n");
            exit(0);
        } elsif ($#running_jobs eq 0) {
            $connect_job = $running_jobs[0]->{job_id};
        } else {
            my $running_jobs_str = join(
                ", ",
                map {
                    "$_->{job_id}" . (defined($_->{job_name}) ? " (" . $_->{job_name} . ")" : "")
                } @running_jobs);
            print("You have several running jobs. Please provide a job id.\n");
            print("Running jobs are: $running_jobs_str\n");
            exit(0);
        }
    }

    # Do not kill the job if the user close the window
    $SIG{HUP} = 'DEFAULT';
    OAR::Sub::close_db_connection();
    exit(connect_job($connect_job, 0, $Openssh_cmd));
}

# End connection to a reservation

if (($Interactive == 0) and ($ARGV[0] ne "" or grep(/^noop(?:=standby)?$/, @Type))) {
    my $exec = $ARGV[0];
    if (defined($Scan_script)) {
        my $scan_result_tmp = OAR::Sub::scan_script($exec, $Initial_request_string)
          if ($exec ne "");
        my %scan_result = %$scan_result_tmp;
        $Initial_request_string = $scan_result{initial_request};
        if (defined($scan_result{queue}) && !defined($Queue_name)) {
            $Queue_name = $scan_result{queue};
        } elsif (defined($scan_result{queue}) && defined($Queue_name)) {
            warn(
                "# Warning: ignore script value for queue parameter: $scan_result{queue}; another value was given on the command line.\n"
            );
        }
        if (defined($scan_result{property}) && ($Job_sql_properties eq "")) {
            $Job_sql_properties = $scan_result{property};
        } elsif (defined($scan_result{property}) && ($Job_sql_properties ne "")) {
            warn(
                "# Warning: ignore script value for property parameter: $scan_result{property}; another value was given on the command line.\n"
            );
        }
        if (defined($scan_result{resources})) {
            push(@resource, @{ $scan_result{resources} });
        }
        if (defined($scan_result{types})) {
            push(@Type, @{ $scan_result{types} });
        }
        if (defined($scan_result{anterior})) {
            push(@Anterior_job, @{ $scan_result{anterior} });
        }
        if (defined($scan_result{checkpoint}) && ($Checkpoint == 0)) {
            $Checkpoint = $scan_result{checkpoint};
        } elsif (defined($scan_result{checkpoint}) && ($Checkpoint != 0)) {
            warn(
                "# Warning: ignore script value for checkpoint parameter: $scan_result{checkpoint}; another value was given on the command line.\n"
            );
        }
        if (defined($scan_result{notify}) && (!defined($notify))) {
            $notify = $scan_result{notify};
        } elsif (defined($scan_result{notify}) && (defined($notify))) {
            warn(
                "# Warning: ignore script value for notify parameter: $scan_result{notify}; another value was given on the command line.\n"
            );
        }
        if (defined($scan_result{directory})) {
            $Directory = $scan_result{directory};
        }
        if (defined($scan_result{directory}) && (!defined($Directory))) {
            $Directory = $scan_result{directory};
        } elsif (defined($scan_result{directory}) && (defined($Directory))) {
            warn(
                "# Warning: ignore script value for name parameter: $scan_result{directory}; another value was given on the command line.\n"
            );
        }
        if (defined($scan_result{name}) && (!defined($job_name))) {
            $job_name = $scan_result{name};
        } elsif (defined($scan_result{name}) && (defined($job_name))) {
            warn(
                "# Warning: ignore script value for name parameter: $scan_result{name}; another value was given on the command line.\n"
            );
        }
        if (defined($scan_result{project}) && (!defined($Project))) {
            $Project = $scan_result{project};
        } elsif (defined($scan_result{project}) && (defined($Project))) {
            warn(
                "# Warning: ignore script value for name parameter: $scan_result{project}; another value was given on the command line.\n"
            );
        }
        if (defined($scan_result{hold}) && (!defined($job_hold))) {
            $job_hold = $scan_result{hold};
        } elsif (defined($scan_result{hold}) && (defined($job_hold))) {
            warn(
                "# Warning: ignore script value for hold parameter: $scan_result{hold}; another value was given on the command line.\n"
            );
        }
        if (defined($scan_result{signal}) && (!defined($Checkpoint_signal))) {
            $Checkpoint_signal = $scan_result{signal};
        } elsif (defined($scan_result{signal}) && (defined($Checkpoint_signal))) {
            warn(
                "# Warning: ignore script value for hold parameter: $scan_result{signal}; another value was given on the command line.\n"
            );
        }
        if (defined($scan_result{stdout}) && (!defined($Stdout_file))) {
            $Stdout_file = $scan_result{stdout};
        } elsif (defined($scan_result{stdout}) && (defined($Stdout_file))) {
            warn(
                "# Warning: ignore script value for stdout parameter: $scan_result{stdout}; another value was given on the command line.\n"
            );
        }
        if (defined($scan_result{stderr}) && (!defined($Stderr_file))) {
            $Stderr_file = $scan_result{stderr};
        } elsif (defined($scan_result{stderr}) && (defined($Stderr_file))) {
            warn(
                "# Warning: ignore script value for stderr parameter: $scan_result{stderr}; another value was given on the command line.\n"
            );
        }
        if (defined($scan_result{usejobkey})) {
            $use_job_key = 1;
        }
        if (defined($scan_result{importjobkeyinlinepriv}) && ($import_job_key_inline eq "")) {
            $import_job_key_inline = $scan_result{importjobkeyinlinepriv};
        } elsif (defined($scan_result{importjobkeyinlinepriv}) && ($import_job_key_inline ne "")) {
            warn(
                "# Warning: ignore script value for import-job-key-inline-priv parameter: $scan_result{importjobkeyinlinepriv}; another value was given on the command line.\n"
            );
        }
        if (defined($scan_result{importjobkeyfromfile}) && ($import_job_key_file eq "")) {
            $import_job_key_file = $scan_result{importjobkeyfromfile};
        } elsif (defined($scan_result{importjobkeyfromfile}) && ($import_job_key_file ne "")) {
            warn(
                "# Warning: ignore script value for import-job-key-from-file parameter: $scan_result{importjobkeyfromfile}; another value was given on the command line.\n"
            );
        }
        if (defined($scan_result{exportjobkeytofile}) && ($export_job_key_file eq "")) {
            $export_job_key_file = $scan_result{exportjobkeytofile};
        } elsif (defined($scan_result{exportjobkeytofile}) && ($export_job_key_file ne "")) {
            warn(
                "# Warning: ignore script value for export-job-key-to-file parameter: $scan_result{exportjobkeytofile}; another value was given on the command line.\n"
            );
        }
        if (defined($scan_result{array}) && (!defined($array_job_nb))) {
            $array_job_nb = $scan_result{array};
        } elsif (defined($scan_result{array}) && (defined($array_job_nb))) {
            warn(
                "# Warning: ignore script value for array parameter: $scan_result{array}; another value was given on the command line.\n"
            );
        }
        if (defined($scan_result{arrayparamfile}) && (!defined($array_param_file))) {
            $array_param_file = $scan_result{arrayparamfile};
        } elsif (defined($scan_result{arrayparamfile}) && (defined($array_param_file))) {
            warn(
                "# Warning: ignore script value for array-param-file parameter: $scan_result{arrayparamfile}; another value was given on the command line.\n"
            );
        }
    }

    my @resource_list = parse_resource_descriptions(\@resource);

    $Project           = $Project_default           if (!defined($Project));
    $Checkpoint_signal = $Checkpoint_signal_default if (!defined($Checkpoint_signal));
    $Directory         = $Directory_default         if (!defined($Directory));

    # array_ids are assigned automatically
    if (defined($array_param_file)) {
        $array_params_ref = OAR::Sub::read_array_param_file($array_param_file);
        $array_job_nb     = scalar @{$array_params_ref};
    }

    $array_job_nb = 1 if (!defined($array_job_nb));
    if ($array_job_nb <= 0) {
        warn("# Error: an array job must have a positive number of sub-jobs.\n");
        usage();
        OAR::Sub::close_db_connection();
        exit(6);
    }

    $Cmd_executor = "Qsub";

    ($Server, my $server_port) = parse_reservation(0, \@resource_list);

    $Job_id_list_ref = OAR::Sub::add_micheline_job(
        "PASSIVE",               \@resource_list,
        $exec,                   "$Host:$server_port",
        $Queue_name,             $Job_sql_properties,
        $Reservation_start,      defined($idFile) ? $idFile : "NULL",
        $Checkpoint,             $Checkpoint_signal,
        $notify,                 $job_name,
        $job_env,                \@Type,
        $Directory,              \@Anterior_job,
        $Stdout_file,            $Stderr_file,
        $job_hold,               $Project,
        $use_job_key,            $import_job_key_inline,
        $import_job_key_file,    $export_job_key_file,
        $Initial_request_string, $array_job_nb,
        $array_params_ref,       $Verbose_level);
} else {
    if ($ARGV[0] ne "") {
        warn(
            "# Warning: you asked for an Interactive job SO I will ignore arguments: $ARGV[0] ; Is your syntax right?\n"
        );
    }
    $Cmd_executor = "Qsub -I";

    my @resource_list = parse_resource_descriptions(\@resource);

    if (defined($array_param_file)) {
        warn("# Error: a parameter file-based array job cannot be interactive.\n");

        # user defined array_ids, 0 if interactive and/or non-array job
        usage();
        OAR::Sub::close_db_connection();
        exit(9);
    }

    $Project           = $Project_default           if (!defined($Project));
    $Checkpoint_signal = $Checkpoint_signal_default if (!defined($Checkpoint_signal));
    $Directory         = $Directory_default         if (!defined($Directory));

    $array_job_nb = 1 if (!defined($array_job_nb));
    if ($array_job_nb != 1) {
        warn("# Error: an array job cannot be interactive.\n");
        usage();
        OAR::Sub::close_db_connection();
        exit(8);
    }

    ($Server, my $server_port) = parse_reservation(1, \@resource_list);

    $Job_id_list_ref = OAR::Sub::add_micheline_job(
        "INTERACTIVE",           \@resource_list,
        "",                      "$Host:$server_port",
        $Queue_name,             $Job_sql_properties,
        $Reservation_start,      defined($idFile) ? $idFile : "NULL",
        $Checkpoint,             $Checkpoint_signal,
        $notify,                 $job_name,
        $job_env,                \@Type,
        $Directory,              \@Anterior_job,
        $Stdout_file,            $Stderr_file,
        $job_hold,               $Project,
        $use_job_key,            $import_job_key_inline,
        $import_job_key_file,    $export_job_key_file,
        $Initial_request_string, $array_job_nb,
        $array_params_ref,       $Verbose_level);
}

if ((!defined($Job_id_list_ref)) or (ref($Job_id_list_ref) ne "ARRAY")) {
    OAR::Sub::close_db_connection();
    exit($Job_id_list_ref);
}

if (@{$Job_id_list_ref} > 1) {
    for my $j (@{$Job_id_list_ref}) {
        if ($j > 0 or $Verbose_level >= 1) {
            print("OAR_JOB_ID=" . $j . "\n");
        }
    }
    print("OAR_ARRAY_ID=" . OAR::Sub::get_job_array_id($Job_id_list_ref->[0]) . "\n");
} else {
    if ($Job_id_list_ref->[0] > 0 or $Verbose_level >= 1) {
        print("OAR_JOB_ID=" . $Job_id_list_ref->[0] . "\n");
    }
}

if ((defined($DUMPER_mode)) or (defined($YAML_mode) or ($XML_mode) or ($JSON_mode))) {
    print("\n##########\n");
    foreach my $Job_id (@{$Job_id_list_ref}) {
        my $tmp = { job_id => $Job_id };
        if (defined($DUMPER_mode)) {
            print(Dumper($tmp));
        } elsif (defined($XML_mode)) {
            if ($XML_enabled == 1) {
                my $dump = new XML::Dumper;
                $dump->dtd;
                print($dump->pl2xml($tmp));
            } else {
                warn(
                    "XML module not available on the system. Ask your administrator to install it if needed.\n"
                );
            }
        } elsif (defined($YAML_mode)) {
            if ($YAML_enabled == 1) {
                print(YAML::Dump($tmp));
            } else {
                warn(
                    "YAML module not available on the system. Ask your administrator to install it if needed.\n"
                );
            }
        } elsif (defined($JSON_mode)) {
            if ($JSON_enabled == 1) {
                print(JSON->new->pretty(1)->encode($tmp));
            } else {
                warn(
                    "JSON module not available on the system. Ask your administrator to install it if needed.\n"
                );
            }
        }
    }
    print("\n##########\n\n");
}

OAR::Sub::close_db_connection();

if ((@{$Job_id_list_ref} < 1) or ($Job_id_list_ref->[-1] <= 0)) {
    warn("# Error: please verify your job submission syntax.\n");
    exit(8);
}

#Signal Almigthy
if (defined(OAR::Sub::signal_almighty($remote_host, $remote_port, "$Cmd_executor"))) {

    #qdel(1);
    warn("# Error: cannot connect to executor $remote_host:$remote_port. Job is killed.\n");
    exit(9);
}

my $answer;
if ($Reservation ne "0") {

    #Reservation mode
    print("# Advance reservation request: waiting for validation...\n");
    my $client = $Server->accept();
    my $advance_reservation_validation_hook =
      get_conf("ADVANCE_RESERVATION_VALIDATION_HOOK_EXEC_FILE");
    $answer = <$client>;
    chop($answer);
    if ($answer eq "GOOD RESERVATION") {
        print("# Reservation valid --> OK\n");
        if (defined($advance_reservation_validation_hook)) {
            run_advance_reservation_validation_hook($advance_reservation_validation_hook, 1);
        }
    } else {
        print("# Reservation not valid --> KO ($answer)\n");
        if (defined($advance_reservation_validation_hook)) {
            run_advance_reservation_validation_hook($advance_reservation_validation_hook, 0);
        }
        exit(10);
    }
} elsif ($Interactive == 1) {

    #Interactive mode
    print("# Interactive mode: waiting...\n");
    my $prev_str = "";
    do {
        my $client = $Server->accept();
        $answer = <$client>;
        chomp($answer);
        if ($answer =~ /\](.*)$/) {
            if ($1 ne $prev_str) {
                print("# $answer\n");
                $prev_str = $1;
            }
        } elsif ($answer ne "GOOD JOB") {
            print("# $answer\n");
        }
      } while (($answer ne "GOOD JOB") and
        ($answer ne "BAD JOB")    and
        ($answer ne "JOB KILLED") and
        ($answer !~ /^ERROR/));
    if ($answer eq "GOOD JOB") {
        exit(connect_job($Job_id_list_ref->[0], 1, $Openssh_cmd));
    } else {
        exit(11);
    }
}

exit(0);
